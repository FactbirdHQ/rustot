use core::convert::TryFrom;
use core::fmt::Debug;

use super::data_types::ErrorResponse;

#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Error {
    Overflow,
    NoPersistence,
    DaoRead,
    DaoWrite,
    InvalidPayload,
    WrongShadowName,
    Mqtt,
    ShadowError(ShadowError),
}

// =============================================================================
// KV-based shadow storage error types (Phase 1)
// =============================================================================

/// Unified error type for KV-based shadow operations.
///
/// Generic over the KV store's error type to avoid boxing.
#[derive(Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum KvError<E: Debug> {
    /// KV store operation failed
    Kv(E),

    /// Serialization/deserialization error
    Serialization,

    /// Path not found in schema
    PathNotFound,

    /// Key exceeds maximum length
    KeyTooLong,

    /// Enum variant mismatch (delta variant doesn't match current state)
    VariantMismatch,

    /// Unknown enum variant name
    UnknownVariant,

    /// Invalid stored variant data
    InvalidVariant,

    /// Migration error
    Migration(super::migration::MigrationError),
}

impl<E: Debug> From<super::migration::MigrationError> for KvError<E> {
    fn from(e: super::migration::MigrationError) -> Self {
        KvError::Migration(e)
    }
}

impl<E: Debug> core::fmt::Display for KvError<E> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            KvError::Kv(e) => write!(f, "KV store error: {:?}", e),
            KvError::Serialization => write!(f, "serialization error"),
            KvError::PathNotFound => write!(f, "path not found"),
            KvError::KeyTooLong => write!(f, "key too long"),
            KvError::VariantMismatch => write!(f, "variant mismatch"),
            KvError::UnknownVariant => write!(f, "unknown variant"),
            KvError::InvalidVariant => write!(f, "invalid variant"),
            KvError::Migration(e) => write!(f, "migration error: {:?}", e),
        }
    }
}

#[cfg(feature = "std")]
impl<E: Debug> std::error::Error for KvError<E> {}

/// Error type for enum field operations.
///
/// Used by `set_enum_variant()` and `get_enum_variant()`.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum EnumFieldError {
    /// The field path doesn't refer to an enum field
    NotAnEnumField,

    /// The variant name is not valid for this enum
    UnknownVariant,
}

/// Metadata about an enum field in the shadow schema.
///
/// Generated by the derive macro for each enum field.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EnumFieldMeta {
    /// The path to this enum field (e.g., "network" or "config/mode")
    pub path: &'static str,

    /// Valid variant names for this enum (serde-renamed)
    pub variants: &'static [&'static str],
}

/// Error type for delta parsing operations.
///
/// Returned by `ShadowNode::parse_delta()` when JSON parsing fails.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum ParseError {
    /// JSON scanning failed (malformed JSON)
    Scan(super::tag_scanner::ScanError),

    /// Serde deserialization failed
    Deserialize,

    /// Unknown enum variant name
    UnknownVariant,

    /// Missing variant tag and no fallback available
    MissingVariant,

    /// Content present but wrong type for variant
    ContentTypeMismatch,
}

impl From<super::tag_scanner::ScanError> for ParseError {
    fn from(e: super::tag_scanner::ScanError) -> Self {
        ParseError::Scan(e)
    }
}

impl core::fmt::Display for ParseError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            ParseError::Scan(e) => write!(f, "JSON scan error: {}", e),
            ParseError::Deserialize => write!(f, "deserialization failed"),
            ParseError::UnknownVariant => write!(f, "unknown enum variant"),
            ParseError::MissingVariant => write!(f, "missing variant tag with no fallback"),
            ParseError::ContentTypeMismatch => write!(f, "content type mismatch for variant"),
        }
    }
}

impl core::fmt::Display for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Error::Overflow => write!(f, "overflow"),
            Error::NoPersistence => write!(f, "no persistence"),
            Error::DaoRead => write!(f, "DAO read error"),
            Error::DaoWrite => write!(f, "DAO write error"),
            Error::InvalidPayload => write!(f, "invalid payload"),
            Error::WrongShadowName => write!(f, "wrong shadow name"),
            Error::Mqtt => write!(f, "MQTT error"),
            Error::ShadowError(e) => write!(f, "shadow error: {:?}", e),
        }
    }
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl From<ShadowError> for Error {
    fn from(e: ShadowError) -> Self {
        Self::ShadowError(e)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum ShadowError {
    InvalidJson,
    MissingState,
    MalformedState,
    MalformedDesired,
    MalformedReported,
    InvalidVersion,
    InvalidClientToken,
    JsonTooDeep,
    InvalidStateNode,
    Unauthorized,
    Forbidden,
    NotFound,
    VersionConflict,
    PayloadTooLarge,
    UnsupportedEncoding,
    TooManyRequests,
    InternalServerError,
}

impl ShadowError {
    pub fn http_code(&self) -> u16 {
        match self {
            ShadowError::InvalidJson
            | ShadowError::MissingState
            | ShadowError::MalformedState
            | ShadowError::MalformedDesired
            | ShadowError::MalformedReported
            | ShadowError::InvalidVersion
            | ShadowError::InvalidClientToken
            | ShadowError::JsonTooDeep
            | ShadowError::InvalidStateNode => 400,

            ShadowError::Unauthorized => 401,
            ShadowError::Forbidden => 403,
            ShadowError::NotFound => 404,
            ShadowError::VersionConflict => 409,
            ShadowError::PayloadTooLarge => 413,
            ShadowError::UnsupportedEncoding => 415,
            ShadowError::TooManyRequests => 429,
            ShadowError::InternalServerError => 500,
        }
    }
}

impl<'a> TryFrom<ErrorResponse<'a>> for ShadowError {
    type Error = ();

    fn try_from(e: ErrorResponse<'a>) -> Result<Self, Self::Error> {
        Ok(match e.code {
            400 | 404 => ShadowError::NotFound,
            401 => ShadowError::Unauthorized,
            403 => ShadowError::Forbidden,
            409 => ShadowError::VersionConflict,
            413 => ShadowError::PayloadTooLarge,
            415 => ShadowError::UnsupportedEncoding,
            429 => ShadowError::TooManyRequests,
            500 => ShadowError::InternalServerError,
            _ => return Err(()),
        })
    }
}
