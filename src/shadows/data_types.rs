use serde::{Deserialize, Serialize};

use super::{tag_scanner::FieldScanner, ParseError, ShadowNode, VariantResolver};

#[derive(Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Patch<T> {
    #[default]
    Unset,
    Set(T),
}

impl<T> Clone for Patch<T>
where
    T: Clone,
{
    fn clone(&self) -> Self {
        match self {
            Self::Unset => Self::Unset,
            Self::Set(v) => Self::Set(v.clone()),
        }
    }
}

impl<T> From<T> for Patch<T> {
    fn from(v: T) -> Self {
        Self::Set(v)
    }
}

#[derive(Serialize)]
pub struct RequestState<D, R> {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub desired: Option<D>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reported: Option<R>,
}

#[derive(Debug, Clone)]
pub struct DeltaState<D, R> {
    pub desired: Option<D>,

    pub reported: Option<R>,

    pub delta: Option<D>,
}

impl<D> DeltaState<D, D> {
    /// Parse a delta state using `FieldScanner` and `parse_delta`.
    ///
    /// This method handles adjacently-tagged enums properly by using
    /// the resolver for variant fallback when the tag is missing.
    ///
    /// Note: This method is only available when `desired`, `reported`, and `delta`
    /// all use the same delta type (which is the common case for shadow responses).
    pub async fn parse<S, Res>(json: &[u8], resolver: &Res) -> Result<Self, ParseError>
    where
        S: ShadowNode<Delta = D>,
        Res: VariantResolver,
    {
        let scanner = FieldScanner::scan(json, &["desired", "reported", "delta"])
            .map_err(ParseError::Scan)?;

        // Parse each field using parse_delta
        let desired = if let Some(bytes) = scanner.field_bytes("desired") {
            Some(S::parse_delta(bytes, "", resolver).await?)
        } else {
            None
        };

        let reported = if let Some(bytes) = scanner.field_bytes("reported") {
            Some(S::parse_delta(bytes, "", resolver).await?)
        } else {
            None
        };

        let delta = if let Some(bytes) = scanner.field_bytes("delta") {
            Some(S::parse_delta(bytes, "", resolver).await?)
        } else {
            None
        };

        Ok(Self {
            desired,
            reported,
            delta,
        })
    }
}

/// A request state document has the following format:
/// - **state** — Updates affect only the fields specified. Typically, you'll
///   use either the desired or the reported property, but not both in the same
///   request.
/// - **desired** — The state properties and values requested to be updated in
///   the device.
/// - **reported** — The state properties and values reported by the device.
/// - **clientToken** — If used, you can match the request and corresponding
///   response by the client token.
/// - **version** — If used, the Device Shadow service processes the update only
///   if the specified version matches the latest version it has.
#[derive(Serialize)]
#[serde(default)]
pub struct Request<'a, D, R> {
    pub state: RequestState<D, R>,

    #[serde(rename = "clientToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_token: Option<&'a str>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// Response accepted state documents have the following format:
/// - **state**
///     - reported — Present only if a thing reported any data in the reported
///       section and contains only fields that were in the request state
///       document.
///     - desired — Present only if a device reported any data in the desired
///       section and contains only fields that were in the request state
///       document.
///     - delta — Present only if the desired data differs from the shadow's
///       current reported data.
/// - **metadata** — Contains the timestamps for each attribute in the desired
///   and reported sections so that you can determine when the state was
///   updated.
/// - **timestamp** — The Epoch date and time the response was generated by AWS
///   IoT.
/// - **clientToken** — Present only if a client token was used when publishing
///   valid JSON to the /update topic.
/// - **version** — The current version of the document for the device's shadow
///   shared in AWS IoT. It is increased by one over the previous version of the
///   document.
pub struct AcceptedResponse<'a, D, R> {
    pub state: DeltaState<D, R>,
    // pub metadata: Metadata<>.
    pub timestamp: u64,
    pub client_token: Option<&'a str>,
    pub version: Option<i64>,
}

impl<'a, D> AcceptedResponse<'a, D, D> {
    /// Parse an accepted response using `FieldScanner` and `parse_delta`.
    ///
    /// This method handles adjacently-tagged enums properly by using
    /// the resolver for variant fallback when the tag is missing.
    ///
    /// Note: This method is only available when `desired`, `reported`, and `delta`
    /// all use the same delta type (which is the common case for shadow responses).
    pub async fn parse<S, Res>(json: &'a [u8], resolver: &Res) -> Result<Self, ParseError>
    where
        S: ShadowNode<Delta = D>,
        Res: VariantResolver,
    {
        let scanner = FieldScanner::scan(json, &["state", "timestamp", "version", "clientToken"])
            .map_err(ParseError::Scan)?;

        // Parse timestamp (default to 0 if missing)
        let timestamp = scanner
            .field_bytes("timestamp")
            .and_then(|b| core::str::from_utf8(b).ok())
            .and_then(|s| s.parse().ok())
            .unwrap_or(0);

        // Parse version
        let version = scanner
            .field_bytes("version")
            .and_then(|b| core::str::from_utf8(b).ok())
            .and_then(|s| s.parse().ok());

        // Parse client_token (strips surrounding quotes)
        let client_token = scanner.field_str("clientToken");

        // Parse state using DeltaState::parse
        let state = if let Some(state_bytes) = scanner.field_bytes("state") {
            DeltaState::parse::<S, Res>(state_bytes, resolver).await?
        } else {
            // No state field - return empty DeltaState
            DeltaState {
                desired: None,
                reported: None,
                delta: None,
            }
        };

        Ok(Self {
            state,
            timestamp,
            client_token,
            version,
        })
    }
}

/// Response accepted state documents have the following format:
/// - **state**
/// - **metadata** — Contains the timestamps for each attribute in the desired
///   and reported sections so that you can determine when the state was
///   updated.
/// - **timestamp** — The Epoch date and time the response was generated by AWS
///   IoT.
/// - **clientToken** — Present only if a client token was used when publishing
///   valid JSON to the /update topic.
/// - **version** — The current version of the document for the device's shadow
///   shared in AWS IoT. It is increased by one over the previous version of the
///   document.
pub struct DeltaResponse<'a, U> {
    pub state: Option<U>,
    // pub metadata: Metadata<>.
    pub timestamp: u64,
    pub client_token: Option<&'a str>,
    pub version: Option<i64>,
}

impl<'a, U> DeltaResponse<'a, U> {
    /// Parse a delta response using `FieldScanner` and `parse_delta`.
    ///
    /// This method handles adjacently-tagged enums properly by using
    /// the resolver for variant fallback when the tag is missing.
    pub async fn parse<S, R>(json: &'a [u8], resolver: &R) -> Result<Self, ParseError>
    where
        S: ShadowNode<Delta = U>,
        R: VariantResolver,
    {
        let scanner = FieldScanner::scan(json, &["state", "timestamp", "version", "clientToken"])
            .map_err(ParseError::Scan)?;

        // Parse timestamp (default to 0 if missing)
        let timestamp = scanner
            .field_bytes("timestamp")
            .and_then(|b| core::str::from_utf8(b).ok())
            .and_then(|s| s.parse().ok())
            .unwrap_or(0);

        // Parse version
        let version = scanner
            .field_bytes("version")
            .and_then(|b| core::str::from_utf8(b).ok())
            .and_then(|s| s.parse().ok());

        // Parse client_token (strips surrounding quotes)
        let client_token = scanner.field_str("clientToken");

        // Parse state using parse_delta
        let state = if let Some(state_bytes) = scanner.field_bytes("state") {
            Some(S::parse_delta(state_bytes, "", resolver).await?)
        } else {
            None
        };

        Ok(Self {
            state,
            timestamp,
            client_token,
            version,
        })
    }
}

/// An error response document has the following format:
/// - **code** — An HTTP response code that indicates the type of error.
/// - **message** — A text message that provides additional information.
/// - **timestamp** — The date and time the response was generated by AWS IoT.
///   This property is not present in all error response documents.
/// - **clientToken** — Present only if a client token was used in the published
///   message.
#[derive(Debug, Deserialize)]
pub struct ErrorResponse<'a> {
    pub code: u16,
    pub message: &'a str,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<u64>,
    #[serde(rename = "clientToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_token: Option<&'a str>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
    struct Test {
        field: bool,
    }

    #[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
    struct TestMap(heapless::LinearMap<heapless::String<3>, Patch<Test>, 5>);

    #[test]
    fn deserialize_patch_unset() {
        let payload = "\"unset\"";

        let (patch, _) = serde_json_core::from_str::<Patch<()>>(payload).unwrap();
        assert_eq!(patch, Patch::Unset);
    }

    #[test]
    fn serialize_map_patch_delta() {
        let payload = "{\"1\":{\"set\":{\"field\":true}}}";

        let mut exp_map = TestMap(heapless::LinearMap::default());
        exp_map
            .0
            .insert(
                heapless::String::try_from("1").unwrap(),
                Patch::Set(Test { field: true }),
            )
            .unwrap();

        let patch = serde_json_core::to_string::<_, 512>(&exp_map).unwrap();
        assert_eq!(patch.as_str(), payload);
    }

    #[test]
    fn deserialize_map_patch_delta() {
        let payload = "{\"1\":{\"set\":{\"field\":true}}}";

        let mut exp_map = TestMap(heapless::LinearMap::default());
        exp_map
            .0
            .insert(
                heapless::String::try_from("1").unwrap(),
                Patch::Set(Test { field: true }),
            )
            .unwrap();

        let (patch, _) = serde_json_core::from_str::<TestMap>(payload).unwrap();
        assert_eq!(patch, exp_map);
    }

    #[test]
    fn deserialize_map_patch_missing() {
        let payload = "{}";

        let exp_map = TestMap(heapless::LinearMap::default());

        let (patch, _) = serde_json_core::from_str::<TestMap>(payload).unwrap();
        assert_eq!(patch, exp_map);
    }

    #[test]
    fn deserialize_map_patch_unset() {
        let payload = "{\"1\":\"unset\"}";

        let mut exp_map = TestMap(heapless::LinearMap::default());
        exp_map
            .0
            .insert(heapless::String::try_from("1").unwrap(), Patch::Unset)
            .unwrap();

        let (patch, _) = serde_json_core::from_str::<TestMap>(payload).unwrap();
        assert_eq!(patch, exp_map);
    }
}
